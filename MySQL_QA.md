[toc]

<div STYLE="page-break-after:always;"></div>

## 基础

### 什么是DDL？列举DDL命令

DDL是数据定义语言，用于数据库和数据表的创建，修改和删除

常用命令如下所示

```mysql
CREATE DATABASE # 创建数据库
ALTER DATABASE # 修改数据库，常用于修改数据库的字符集
DROP DATABASE # 删除数据库
CREATE TABLE #创建数据表，后面需要添加表中的列和列类型
ALTER TABLE #修改数据表，可修改表名（RENAME TO），列名（CHANGE），列类型（MODIFY），列约束（MODIFY）和添加（ADD）/删除（DROP）列
DROP TABLE #删除数据表
CREATE TABLE ... LIKE ... # 按照要求复制表
```

### 如何在已存在的表中添加一个新列？

使用 `ALTER TABLE [表名] ADD [列名] [列类型]` 语句可以添加一个新列

另外还可以使用 `FIRST/AFTER` 规定添加列的位置

### 怎么样删除表？DROP TABLE和DELETE的区别是什么？

可以使用 `DROP TABLE [表名]` 语句删除表和表中的数据

也可以使用 `DELETE FROM [表名]` 只删除表中的数据，保留表的结构

另外使用 `DROP` 语句后，表中数据无法恢复，而使用 `DELETE` 语句后，可以回滚恢复运行前状态

### 什么是DML？列举几个常见的DML命令

DML是数据操作语言，用于查询，添加，修改和删除数据表中的记录

常用命令如下所示

```mysql
SELECT ... FROM ... WHERE ... # 查询指定数据
INSERT INTO ... VALUES (...) # 向表中插入新数据，如果声明了具体的列，插入数据要与列对齐；如果没有声明列，则默认为表中的所有列，且顺序与原表中一致
UPDATE ... SET ... # 修改表中数据
DELETE FROM ... # 删除表中数据
TRUNCATE ... # 清空表中所有数据
```

### 解释SELECT语句的作用。如何筛选特定的行？

`SELECT` 语句用于从数据表中查找数据，可以检索整个表或筛选特定的列和行，并支持排序、分组、计算等功能

筛选条件常设置于 `WHERE` 子句中，其中可以使用等值条件，不等值条件，模糊查询条件，范围查询条件等

### 什么是DCL？提供一些DCL命令的示例

DCL是数据控制语言，用于管理数据库用户权限和控制数据访问

常用命令如下所示

```mysql
GRANT # 向用户授予数据库权限
REVOKE # 撤销用户权限
SHOW GRANTS # 查看用户权限
DROP USER # 删除用户
```

### 如何授予用户访问数据库的权限？使用GRANT语句的示例

使用 `GRANT` 语句授予用户访问数据库的权限

相应语法：`GRANT 权限列表 ON 数据库.表 TO '用户名'@'主机' [WITH GRANT OPTION];`

其中 `数据库.表` 表示用户权限的作用范围，如果要对所有数据库和表可使用 `*.*`

`WITH GRANT OPTION` 代表是否允许该用户将权限授予其他用户

权限列表如下表所示

| 权限           | 作用                   |
| -------------- | ---------------------- |
| ALL PRIVILEGES | 赋予所有权限           |
| SELECT         | 允许 `SELECT` 查询数据 |
| INSERT         | 允许 `INSERT` 插入数据 |
| UPDATE         | 允许 `UPDATE` 修改数据 |
| DELETE         | 允许 `DELETE` 删除数据 |
| CREATE         | 允许创建数据库或表     |
| DROP           | 允许删除数据库或表     |
| ALTER          | 允许修改表结构         |
| EXECUTE        | 允许执行存储过程       |

### 什么是TCL？列举几个常见的TCL命令

TCL是事务控制语言，用于管理数据库事务，保证数据的一致性，完整性和持久性

常用命令如下所示

```mysql
SET AUTOCOMMIT=0; # 禁用自动提交功能
START TRANSACTION; # 开始事务
COMMIT; # 提交事务
ROLLBACK; # 回滚事务
SAVEPOINT; # 创建保存点，方便部分回滚
```

### 如何开始一个事务？使用BEGIN或START TRANSACTION语句的示例

首先需要使用 `SET AUTOCOMMIT=0;` 语句禁用自动提交功能，这样 `UPDATE` 等隐式事务语句才不会自动提交

然后使用 `START TRANSACTION;` 语句声明事务的开始，并在事务中写入相应的SQL语句

如果需要设置保存点，保证保存点之前的语句无论为何都能提交成功，可使用 `SAVEPOINT;` 语句创建保存点

最后如果需要提交事务，则使用 `COMMIT;` 语句；否则使用 `ROLLBACK;` 语句回滚，返回事务开始前状态

### 解释ACID是什么意思，以及每个属性的含义是什么？

ACID是事务的四大特性

1. **原子性**(Atomicity)：一个事务中的所有操作要么全部完成，要么全部不完成，不会结束在中间的某个环节。并且在执行过程中如果出现错误，会回滚到开始前的状态
2. **一致性**(Consistency)：一个事务操作前和操作后的数据要满足完整性约束，数据库保持一致性状态
3. **隔离性**(Isolation)：因为数据库允许多个并发事务同时对其数据进行读写和修改，所以需要将每个事务隔离开，保证一个事务的执行不会影响到其他事务
4. **持久性**(Durability)：一旦事务被提交，它对数据库的改变就是永久性的，即使在系统故障或崩溃后也能够保持，被撤销事务的影响是可恢复的

### 什么是并发控制？为什么在数据库中需要进行并发控制？

并发控制是数据库管理系统在多个事务同时执行时，确保数据一致性，完整性和隔离型的机制，主要是为了防止因多个事务并发访问数据库而而导致的数据冲突或不一致

如果没有有效的并发控制，可能会引发脏读，不可重复读和幻读等问题

1. **脏读**：事务 A 读取了事务 B **未提交** 的数据
2. **不可重复读**：事务 A 先读取某条数据，事务 B **修改并提交** 该数据后，事务 A 再次读取时，得到不同的结果
3. **幻读**：事务 A 读取一组数据，事务 B **插入或删除** 了一些数据并提交后，事务 A 再次查询时，数据集的数量发生了变化

### 什么是事务隔离级别？MySQL支持哪些事务隔离级别？

为了避免并发问题，数据库提供不同的事务隔离级别，决定了事务之间相互可见的程度，MySQL一共支持四种事务隔离级别

| 隔离级别                         | 解决的并发问题       | 可能存在的问题                 |
| -------------------------------- | -------------------- | ------------------------------ |
| **READ UNCOMMITTED（未提交读）** | 无                   | 可能发生脏读、不可重复读、幻读 |
| **READ COMMITTED（提交读）**     | 避免脏读             | 可能发生不可重复读、幻读       |
| **REPEATABLE READ（可重复读）**  | 避免脏读和不可重复读 | 可能发生幻读                   |
| **SERIALIZABLE（可串行化）**     | 完全避免所有问题     | 无（但影响并发性能）           |

其中MySQL默认的事务隔离级别为可重复读

### 介绍MySQL中的锁类型：共享锁（S锁）和排他锁（X锁）

**共享锁**允许多个事务同时读取一条数据，但不允许修改数据，即多个事务可同时持有S锁。如果一个事务对相关数据添加了S锁，则其他事务不能添加X锁，直到S锁被释放，这种锁适合于只读操作

```mysql
LOCK IN SHARE MODE # 使用语句可以添加共享锁
```

**排他锁**允许事务读取并修改数据，同时阻塞其他事务访问该数据的操作，即只有一个事务可以获得X锁，适用于修改（写入）操作，如 `INSERT` , `UPDATE` 和 `DELETE`

```mysql
FOR UPDATE # 使用语句设置排他锁
```

### 什么是主键索引？如何定义主键索引？

**主键索引（Primary Key Index）** 是 **MySQL** 中的一种特殊索引，用于唯一标识表中的每一行数据。主键索引有以下特点：

- **唯一性**：主键列的值必须**唯一**，不能重复。
- **非空（NOT NULL）**：主键列的值**不能为空**。
- **自动创建索引**：当设置某列为 **PRIMARY KEY** 时，MySQL **自动创建 B+ 树索引**（在 InnoDB 存储引擎中）。

### 什么是唯一索引？如何定义唯一索引？

**唯一索引（Unique Index）** 是一种特殊的索引，**保证索引列中的值是唯一的**，即不允许重复值，但可以包含 `NULL`（在 MySQL 中）。唯一索引有以下特点：

- **唯一性**：索引列的值不能重复。
- **允许 `NULL`**：唯一索引的列可以包含 `NULL`，但 `NULL` 值不算作重复值。
- **加速查询**：唯一索引会提高查询性能，类似于普通索引，但保证数据不重复。
- **可以有多个唯一索引**：一张表可以有多个唯一索引（但只能有一个主键）。

### 什么是索引碎片化？它如何影响性能？

**索引碎片化（Index Fragmentation）** 是指 数据库索引存储结构因频繁的 `INSERT`、`UPDATE` 和 `DELETE` 操作而变得零散和低效，导致数据库查询性能下降。主要表现为

- **页分裂（Page Splitting）**：在索引页填满后，新数据插入时，数据库必须拆分索引页，导致索引页数量增加、查询路径变长。
- **页空洞（Page Gaps）**：删除或更新索引数据后，原有索引页的部分空间变为空白，未能充分利用。
- **索引顺序错乱**：大量非顺序插入会导致索引结构不连续，影响范围查询。

影响性能的方式：

1. 增加磁盘空间占用
   - 索引碎片化导致大量**无效页**，即使数据量不大，但索引页变多，数据库必须存储更多的无用数据块
2. 查询性能下降
   - 索引结构**不连续**，导致数据库**需要更多 I/O 操作** 来访问数据
3. 更新和删除操作变慢
   - 索引碎片化导致索引页**利用率低**，导致数据库在 `DELETE` 和 `UPDATE` 时，可能需要扫描更多的索引页
4. 批量插入性能下降
   - **索引碎片化会降低批量 `INSERT` 的效率**，因为数据库需要重新组织索引结构，而不是简单地追加数据

## 原理

### InnoDB与MyISAM存储引擎之间的主要区别是什么？

**InnoDB引擎**提供了对事务ACID的支持，是目前MySQL的默认存储引擎

  * 优点：支持事务和崩溃修复能力；引入了行级锁和外键约束
  * 缺点：占用的数据空间相对较大
  * 适用场景：需要事务支持，并且有较高的并发读写频率

**MyISAM引擎**是早期的默认存储引擎，数据以紧密格式存储

  * 优点：访问速度快
  * 缺点：不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键
  * 适用场景：对事务完整性没有要求；表的数据都会只读的

### InnoDB的存储方式是什么？它如何支持事务？

InnoDB采用 **页（Page）存储结构**，并使用 **索引组织表（Index-Organized Table, IOT）** 来管理数据

表存储

- **表数据存储在磁盘上的 `.ibd` 文件**（如果开启 `innodb_file_per_table`）。
- **默认采用 B+ 树索引组织表**（即数据存储在主键索引中）。
- **每个表的主键索引（Clustered Index）存储了所有行数据**，二级索引（Secondary Index）只存储主键值。

索引存储

- **聚簇索引（Clustered Index）**：

  - **主键索引就是数据存储**，主键索引的叶子节点**直接存储整行数据**。

  - **表必须有主键**，如果没有，InnoDB 会自动创建**隐式主键（6 字节 row_id）**。

  - **插入顺序存储**，适合范围查询。

- **二级索引（Secondary Index）**：

  - 索引叶子节点不存储完整行数据，而存主键 ID。

  - 查询二级索引时，需要先查二级索引，再回表查主键索引。

事务日志存储

- `redo log`（重做日志）：保证事务持久性（WAL 机制）
  - 事务修改数据时，先写 **redo log**，再写磁盘，提高性能。
  - **崩溃恢复时**，MySQL 可根据 `redo log` **重做未完成的事务**，确保数据不丢失。
- `undo log`（回滚日志）：支持事务回滚 & MVCC
  - `undo log` 记录修改前的旧数据（快照），用于事务回滚和 **MVCC 读（多版本控制）**。
  - **支持 `ROLLBACK`**：事务失败时，回滚到 `undo log` 记录的旧数据。

支持事务的方式

1. 通过回滚日志记录事务修改前的数据，当事务回滚时，使用日志恢复原始数据，保证了原子性
2. 通过外键约束，事务回滚，双写缓冲区保证了一致性
3. 通过设置不同的事务隔离级别，避免并发问题，保证了隔离性
4. 通过重做日志与WAL机制保证了持久性

### 如何优化InnoDB的性能？提供一些建议

1. 索引优化
   - 使用合适的索引，例如使用主键索引，创建二级索引。另外避免索引失效
   - 使用覆盖索引，保证查询数据都包含在索引中，避免回表查询
   - 避免过多的索引，不必要的索引会降低写入性能
2. 缓存优化
   - 调整相应参数，如缓存池大小，cache大小
3. 事务优化
   - 使用合适的事物隔离级别
   - 避免长事务，长时间未提交的事务会占用大量回滚日志
4. 表设计优化
   - 选择合适的数据类型
   - 对于大数据，使用分区表（PARTITION）提高查询效率

### InnoDB的崩溃恢复是如何工作的？

InnoDB 采用 **事务日志（redo log 和 undo log）** 以及 **WAL（Write-Ahead Logging）机制** 来保证数据库的持久性（Durability），当 MySQL 服务器崩溃时，InnoDB 可以通过 **崩溃恢复（Crash Recovery）** 自动修复未完成的事务，保证数据一致性

**MySQL 崩溃时可能发生的情况**
| 事务状态                     | 影响                                      | InnoDB 如何恢复？                        |
| ---------------------------- | ----------------------------------------- | ---------------------------------------- |
| **事务已提交**（`COMMIT`）   | 事务已经写入 `redo log`，但数据未写入磁盘 | 使用 `redo log` 重做事务，确保数据持久化 |
| **事务未提交**（`ROLLBACK`） | 事务正在执行，数据写入 `undo log`         | 使用 `undo log` 回滚事务，保持一致性     |
| **事务部分写入磁盘**         | 数据库宕机，部分数据已写入                | 通过 `redo log` 补全写入                 |

**InnoDB 崩溃恢复的 4 个阶段**

1. 事务日志检查：读取 **`redo log` 和 `undo log`**，确定哪些事务未提交，哪些事务已提交但未写入磁盘
2. 应用重做日志：如果事务已提交（`COMMIT`），但数据未完全写入磁盘，InnoDB 使用 **`redo log`** 重做事务，确保数据一致
3. 应用回滚日志：未提交的事务（崩溃时还未 `COMMIT`）需要回滚
4. 释放锁和清理日志：释放因崩溃导致的未释放锁，防止数据阻塞。清理 `redo log` 和 `undo log`，恢复正常运行

### 什么是MySQL的缓冲池（Buffer Pool）？

MySQL **InnoDB 缓冲池（Buffer Pool）** 是一个 **内存缓存区域**，用于存储 **索引、数据页、插入缓冲（change buffer）、锁信息等**，减少磁盘 I/O，提高数据库性能。其核心作用包括：

- **加速查询**：查询数据时，**先在缓冲池中查找**，如果未命中（Miss），再从磁盘读取。
- **减少磁盘 I/O**：频繁访问的数据保存在内存中，避免重复读取磁盘，提高性能。
- **缓存修改数据**：事务提交时，数据**先写入缓冲池**，然后异步刷入磁盘，提高事务处理速度。

缓冲池主要由以下几个部分组成：

| 组件                                      | 作用                                   |
| ----------------------------------------- | -------------------------------------- |
| **数据页（Data Pages）**                  | 缓存表的数据页，加速查询               |
| **索引页（Index Pages）**                 | 缓存 B+ 树索引，提高索引查询性能       |
| **插入缓冲（Change Buffer）**             | 缓存二级索引的插入、删除，提高写入性能 |
| **自适应哈希索引（Adaptive Hash Index）** | 热点数据自动构建哈希索引，加速查询     |
| **Undo 页（Undo Pages）**                 | 事务 `undo log` 缓存，支持 MVCC 和回滚 |
| **日志缓冲（Log Buffer）**                | 缓存 `redo log`，减少磁盘写入频率      |

### InnoDB和MyISAM存储引擎在缓冲池方面的行为有什么区别？

| **对比项**       | **InnoDB（事务型存储引擎）** | **MyISAM（非事务型存储引擎）** |
| ---------------- | ---------------------------- | ------------------------------ |
| **缓冲池类型**   | Buffer Pool                  | Key Buffer                     |
| **缓存的数据**   | 数据页、索引页、事务日志     | 仅索引页（数据依赖 OS 缓存）   |
| **缓存写入策略** | 先写缓冲池，后台线程刷盘     | 直接写入磁盘，索引变更缓存     |
| **缓存控制参数** | `innodb_buffer_pool_size`    | `key_buffer_size`              |
| **事务支持**     | ✅ 支持 ACID 事务             | ❌ 不支持事务                   |
| **MVCC 机制**    | ✅ 支持 `undo log`            | ❌ 不支持                       |
| **适用场景**     | 读写并发高、事务性应用       | 只读、低并发应用               |

### 什么是LRU（最近最少使用）算法？它在缓冲池中的使用是怎样的？

LRU是一种缓存淘汰策略，其核心思想为当缓存（或缓冲池）已满，需要淘汰某个元素时，优先淘汰**最近最少**使用的元素，即最长时间未被访问的数据

InnoDB 通过 LRU 机制来决定哪些页面需要从缓冲池中淘汰，以便为新的数据页腾出空间。

**1. InnoDB 缓冲池（Buffer Pool）**

- InnoDB 存储引擎会将从磁盘加载的数据页缓存到 **缓冲池**，以减少磁盘 I/O，提高查询性能。
- 缓冲池使用 **LRU 机制** 来管理数据页的生命周期。

**2. LRU 在 MySQL 缓冲池中的实现**

- 传统的 LRU 直接淘汰最久未被访问的页面，但这样可能会导致热点数据（如全表扫描）冲刷掉真正的热点数据。
- 为了解决这个问题，**InnoDB 采用了改进的 LRU 机制（分段 LRU）**。

### 什么是脏页？缓冲池中的脏页是如何处理的？

脏页是指被修改但尚未写回磁盘的数据页，其主要来源于

1. **事务的写操作**
   - 当 `UPDATE`、`INSERT` 或 `DELETE` 修改数据时，InnoDB **修改缓冲池中的数据页，并记录 redo log（重做日志）**，但不会立即刷盘。
   - 这些被修改的页会被标记为**脏页**。
2. **检查点（Checkpoint）机制**
   - **Checkpoint 触发时，部分脏页会被刷新到磁盘**，以减少数据库崩溃恢复时的日志回放时间。
3. **后台线程的定期刷新**
   - InnoDB **后端后台线程（IO Thread）** 负责定期将脏页写回磁盘，以避免内存溢出。

脏页的处理方式

MySQL 并不会立即将脏页写回磁盘，而是采用**异步写入**策略，主要有以下几种方式：

1. **基于 Checkpoint 机制刷盘**

   - **Checkpoint** 是 MySQL InnoDB 的**崩溃恢复机制**。

   - 当 Checkpoint 触发时，部分脏页会被写回磁盘，以确保数据库在崩溃时能够快速恢复。

2. **后台线程定期刷新**
   - InnoDB **后台线程**（`InnoDB Page Cleaner`）会定期扫描缓冲池，并异步将部分脏页写回磁盘。

3. **用户事务提交时的 `fsync`**
   - 当 `commit` 事务时，如果 `innodb_flush_log_at_trx_commit = 1`，则 MySQL 也会将 `redo log` 刷盘，但数据页可能仍然只是脏页，不一定同步写回磁盘。

4. **MySQL 正常关闭（`shutdown`）**
   - 执行 `mysqladmin shutdown` 时，MySQL 会强制**将所有脏页刷新到磁盘**，确保数据完整性。

### 什么是MySQL的重做日志（Redo Log）？

**重做日志（Redo Log）** 是 MySQL InnoDB 存储引擎提供的一种 **物理日志**，用于 保证事务的**持久性**

当事务执行 `INSERT`、`UPDATE`、`DELETE` 操作时，InnoDB 并不会立即将数据写入磁盘，而是先将变更记录写入 **Redo Log**，然后再**异步**地将数据写入磁盘的数据页。这种机制称为 **WAL（Write-Ahead Logging）**。这可以减少磁盘 I/O，提升性能，并确保数据库崩溃时可以快速恢复数据。

### 重做日志和事务日志（Transaction Log）有什么区别？

重做日志记录数据页的变更，用于保证事务的持久性。而事务日志是一种更加广义的概念，其包含了事务相关的所有日志。重做日志可以看作是事务日志的一部分

| **对比项**     | **Redo Log（重做日志）**                                     | **Transaction Log（事务日志）**                             |
| -------------- | ------------------------------------------------------------ | ----------------------------------------------------------- |
| **作用**       | 保障数据库崩溃恢复，保证数据持久化                           | 记录事务操作，包括 Undo Log、Redo Log 和 Binlog             |
| **记录内容**   | 记录数据页的物理更改（哪个数据页、在哪个偏移量被修改）       | 事务执行的所有信息，包括 SQL 语句、锁信息、回滚信息等       |
| **记录方式**   | **物理日志**（针对数据页的修改）                             | **逻辑日志**（事务的操作步骤）                              |
| **何时写入**   | 事务执行时就写入（WAL 机制：先写日志，再写数据页）           | 事务的整个生命周期都会记录事务日志                          |
| **持久化方式** | 受 `innodb_flush_log_at_trx_commit` 控制，可选每次提交时刷盘或批量写入 | 事务日志的持久化由 **Redo Log 和 Binlog** 共同决定          |
| **是否可回放** | **是**（用于崩溃恢复）                                       | **部分是**（如 Binlog 可用于主从复制，Undo Log 可用于回滚） |
| **存储位置**   | **InnoDB 专用**，存储在 `ib_logfile0`、`ib_logfile1` 等      | **多种日志综合**，包括 Redo Log、Undo Log、Binlog 等        |

### 重做日志是什么时候写入磁盘的？

重做日志采用WAL机制，即先写日志，后写数据，以保证数据持久性和提高性能

其主要流程包括

1. 事务执行时，先写入内存（Redo Log Buffer）

2. 根据刷盘策略（`innodb_flush_log_at_trx_commit`）决定何时写入磁盘（Redo Log 文件）

3. 在 Checkpoint 触发时，部分 Redo Log 被持久化，并释放空间
4. 当MySQL关闭时，Redo Log 会强制写入到磁盘
5. 数据库崩溃后，未写入数据页的 Redo Log 会在恢复时被重放

### 如果数据库崩溃，重做日志如何帮助恢复数据？

当数据库崩溃重启后，如果发现有已提交的事务的 Redo Log，但数据页尚未写入磁盘，MySQL 会重新执行这些操作，确保事务的变更反映到数据页上。

### 什么是MySQL的撤销日志（Undo Log）？

Undo Log 是 MySQL 中用于事务回滚和 MVCC 的日志，其主要作用包括

1. **事务回滚**（Rollback）：如果事务执行过程中发生错误或 `ROLLBACK`，MySQL 需要撤销已执行的更改，使数据库恢复到事务开始前的状态。
2. **MVCC 版本管理**（Multi-Version Concurrency Control）：在 `REPEATABLE READ` 等隔离级别下，未提交事务的更改不会影响其他事务的读取，Undo Log 记录旧版本数据，支持一致性读（Consistent Read）

### 撤销日志和重做日志（Redo Log）有什么区别？

| **对比项**       | **Undo Log（撤销日志）**                                     | **Redo Log（重做日志）**                           |
| ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| **作用**         | 支持事务回滚，保证事务的**原子性（Atomicity）**；支持 **MVCC**，提供一致性快照 | 支持崩溃恢复，保证事务的**持久性（Durability）**   |
| **记录内容**     | **数据修改前的值**（旧版本数据），用于**事务回滚**和**一致性读** | **数据修改后的值**（物理变更），用于**崩溃恢复**   |
| **何时写入**     | **事务执行过程中生成**，回滚时使用                           | **事务提交时写入**，定期刷新到磁盘                 |
| **何时删除**     | **事务提交后不立即删除**，由后台 **Purge 线程清理**          | **事务提交后，随着 Checkpoint 机制，旧日志被覆盖** |
| **存储位置**     | **Undo Tablespace**（独立存储）或 `ibdata1`                  | `ib_logfile0`、`ib_logfile1`                       |
| **主要作用场景** | **回滚事务**、**MVCC 提供一致性读**                          | **崩溃恢复**，在数据库崩溃后重放日志               |
| **是否可回放**   | **是**（回滚事务时使用）                                     | **是**（崩溃恢复时使用）                           |

### 撤销日志是如何支持事务的一致性（Consistency）的？

Undo Log 通过存储数据修改前的值，确保：

1. **事务失败时，可以撤销已执行的操作**，保持数据库一致性。
2. **多事务并发时，提供一致性快照**，确保读取的是符合事务隔离级别的数据。

### 撤销日志的回滚操作是如何实现的？

1. 当事务回滚时，InnoDB查找并读取撤销日志
2. 按照事务执行的反顺序，依次撤销日志中记录的操作
3. 在回滚过程中，InnoDB释放该事务持有的行级锁
4. 事务回滚结束后，删除撤销日志

### MVCC 的基本原理是什么？

**MVCC（Multi-Version Concurrency Control，多版本并发控制）** 是 MySQL InnoDB 存储引擎用于提高数据库 **并发性能** 和 **一致性读（Consistent Read）** 的机制。MVCC 允许多个事务同时访问数据库，而不会相互阻塞，避免了读写冲突，减少了对锁的依赖。

MVCC主要依赖 撤销日志（Undo Log） 来管理数据的不同版本，并结合 事务 ID（Transaction ID） 和隐藏列进行控制。当事务读取某条数据时，InnoDB 需要判断该数据是否**对当前事务可见**，主要依据：

1. 每个数据行都包含一个 `trx_id`（创建事务 ID）
2. 当前事务的 `Read View` 维护了活动事务的 ID 列表
3. 通过比对 `trx_id` 和 `Read View`，决定读取哪个版本

### MVCC 中的版本是如何创建的？

每条记录的不同版本存储在 **Undo Log（撤销日志）**中，事务通过 Undo Log 读取不同版本的数据，实现一致性读（Consistent Read）。每个 InnoDB 数据行都包含两个隐藏的事务 ID 列，用于跟踪版本：

| **隐藏列**         | **作用**                                                     |
| ------------------ | ------------------------------------------------------------ |
| **`trx_id`**       | 记录创建该版本的事务 ID，用于 MVCC 版本控制。                |
| **`roll_pointer`** | 回滚指针，指向 Undo Log，存储旧版本数据，支持一致性读和事务回滚。 |

当事务修改一条数据时：

1. 先将当前记录的旧值存入 Undo Log（不会修改原数据）。
2. 更新数据行的 `trx_id` 为当前事务 ID。
3. 更新 `roll_pointer` 指向 Undo Log，记录旧版本数据。

以下操作会创建新版本

1. **`INSERT` 操作**

   - `INSERT` 直接写入数据页，不会创建 Undo Log。

   - `trx_id` 记录插入该行的事务 ID。

2. **`DELETE` 操作**
   - `DELETE`不会立即删除数据，而是创建一个新版本：
     - 记录事务 ID。
     - 标记该行为删除状态（在 Purge 线程运行前仍可访问）。
     - Undo Log 记录完整的行数据，用于回滚。

3. **`UPDATE` 操作**
   - `UPDATE`不会直接修改数据，而是：
     - 存储旧版本到 Undo Log。
     - 修改数据，并更新 `trx_id` 和 `roll_pointer`。

### MVCC 有哪些优势和劣势？

优势：

1. 读写不互相阻塞，提高并发性能
2. 事务读取一致性快照，提供一致性读
3. 避免大多数加锁操作，降低锁竞争
4. 事务提交后，仍可访问旧版本数据
5. 适用于高并发场景

劣势：

1. 存储开销较大，撤销日志占用大量空间
2. 可能导致幻读
3. 不适用于所有事务隔离级别，只适用于读提交和可重复读
4. 删除和更新操作可能影响性能

### 什么是读视图和写视图？

读视图是InnoDB在事务执行 `SELECT` 语句时创建的**一致性快照**，它决定了当前事务能看到哪些数据版本。其主要作用在于

1. **保证事务的一致性读**（Consistent Read），即事务期间读取的数据不会受到其他事务的影响。
2. **防止脏读、不可重复读**，确保事务在 `REPEATABLE READ` 级别下能够多次读取相同的数据。

写视图用于事务修改数据时控制数据版本，确保写入操作的**可见性**和**事务隔离性**。其主要作用在于

1. 控制写入数据的版本，确保不会修改其他事务**尚未提交**的数据。
2. **避免写入冲突**，保证事务的可串行化（Serializable）。
3. 在 `SERIALIZABLE` 级别下，所有 `SELECT` 语句都会创建写视图并加锁。

### MVCC的主要目标是什么？

MVCC（Multi-Version Concurrency Control，多版本并发控制）的核心目标是 在**高并发**环境下提供一致性读，并避免事务之间的锁冲突，从而提高数据库的**吞吐量和性能**。其主要目标包括：

1. 提高数据库的并发性能，避免读写冲突
2. 提供一致性读，保证事务读取数据的一致性
3. 避免加锁，避免长时间锁等待，提高事务并发性，提高系统吞吐量
4. 解决脏读和不可重复读问题

### 什么是“版本链”（Version Chain）？

**版本链（Version Chain）** 是 MySQL InnoDB 存储引擎 在 **MVCC（多版本并发控制）** 机制下维护的数据版本历史。每条记录的历史版本通过 **Undo Log（撤销日志）** 进行存储，并形成一个链式结构，称为版本链。其主要作用在于

1. **提供一致性读（Consistent Read）**，确保事务在执行过程中**读取到的数据版本一致**，不受其他事务影响
2. **支持事务回滚（Rollback）**，撤销事务的修改，使数据库回到事务开始前的状态。

### 如何避免“脏读”、“不可重复读”和“幻读”问题？

使用不同的事物隔离级别可以避免并发问题

| **问题**       | **原因**                              | **解决方案**                                       |
| -------------- | ------------------------------------- | -------------------------------------------------- |
| **脏读**       | 读取了未提交事务的数据                | **使用 `READ COMMITTED`**                          |
| **不可重复读** | 事务中途，数据被 `UPDATE/DELETE` 修改 | **使用 `REPEATABLE READ`（MySQL 默认）**           |
| **幻读**       | 事务中途，数据被 `INSERT/DELETE` 影响 | **使用 `SERIALIZABLE` 或 `SELECT ... FOR UPDATE`** |

### 为什么需要进行分库分表？

**分库分表** 是数据库**水平扩展**（Scale Out） 的一种方案，主要用于解决单一数据库性能瓶颈，提高系统的并发能力和数据存储能力。当数据量过大或并发请求过多时，单一数据库可能难以承受，这时就需要采用分库分表来优化数据库架构。

主要原因包括

1. 数据量多大，单表查询变慢
2. 单机数据库存储受限
3. 高并发导致的数据库瓶颈
4. 事务锁冲突过多
5. 备份/恢复慢

### 在进行分库分表之前，应该考虑哪些因素？

1. 数据量的增长趋势，当前数据量是否达到瓶颈，数据预计增长情况等
2. 读写比，是否为读写均衡或读少写多的场景
3. 单表查询性能是否已经收到影响
4. 数据库I/O压力，是否存在慢查询或达到瓶颈
5. 选择分库还是分表，以及相应的路由策略

### 如何处理分库分表后的跨分片查询？

1. 分片路由：适用于不涉及大量数据汇总的场景
2. 分片聚合：适用于需要查询多个分片数据的场景
3. 中间件：适用于类单表查询的场景
4. 预聚合数据：适用于数据统计类查询

### 分库分表后如何进行跨库事务操作？

1. XA 事务：MySQL提供的分布式事务机制，支持两阶段提交，适用于涉及少量数据库
2. TCC：适用于业务层控制事务逻辑
3. 事务消息：适用于异步场景
4. SAGA事务：适用于需要长时间运行的事务

## 高可用篇

### 什么是 MySQL 主从复制？

MySQL 主从复制是一种数据库复制机制，在该机制下，一个 MySQL 服务器（主库）将数据变更同步到一个或多个 MySQL 服务器（从库）。主从复制用于数据冗余、负载均衡以及故障恢复。

### 主从复制的基本原理是什么？

主从复制基于 **二进制日志（Binary Log）** 实现，基本流程如下：

1. **主库** 记录所有数据变更到 **二进制日志（binlog）**。
2. **从库** 连接主库，读取 binlog 并存储到 **中继日志（relay log）**。
3. **SQL 线程** 在从库执行中继日志中的 SQL 语句，使从库数据与主库同步。

### 主库和从库之间的数据同步是如何实现的？

数据同步的过程主要包括：

1. **主库记录 binlog**：主库的 `binlog dump thread` 监听并推送变更日志给从库。
2. **从库获取中继日志**：从库的 `IO 线程` 读取主库 binlog，并写入本地的 relay log。
3. **从库回放日志**：从库的 `SQL 线程` 读取 relay log 并执行 SQL 语句，保持数据同步。

### 主从延迟是什么，如何处理？

**主从延迟** 指的是 **主库写入数据后，从库未能立即同步**，导致数据不一致。常见原因：

- **从库 SQL 线程处理过慢**（大批量写入、复杂查询）。
- **网络延迟**（主从服务器间带宽问题）。
- **IO 瓶颈**（从库磁盘写入速度慢）。

**处理方法：**

- **优化主库的 binlog 记录方式**，减少 binlog 体积。
- **使用并行复制**（`replica_parallel_workers > 1`）。
- **从库升级为 SSD，提升磁盘 IO 性能**。
- **使用半同步复制**（semi-sync replication）确保事务提交时至少一个从库同步。

### 主从复制的优点和缺点是什么？

**优点：**

- **读写分离**，提升查询性能。
- **数据冗余**，提高数据可用性。
- **快速故障切换**，增强系统容灾能力。

**缺点：**

- **主从延迟**，可能导致数据不一致。
- **不支持自动故障恢复**，需要手动切换主库。
- **主库单点问题**，如果主库宕机，需手动恢复。

### 什么是 MySQL Cluster？

MySQL Cluster 是一种 **分布式高可用数据库架构**，基于 **NDB 存储引擎**，支持自动数据分片和高可用性。

### MySQL Cluster 的架构是怎样的？

MySQL Cluster 主要由 **三种节点** 组成：

1. **管理节点（Management Node）**：管理集群配置和节点状态。
2. **数据节点（Data Node）**：存储实际数据，支持分片和数据复制。
3. **SQL 节点（SQL Node）**：提供 SQL 访问接口，与数据节点通信。

### MySQL Cluster 如何实现高可用性？

- **数据节点无共享（Shared-nothing）架构**，避免单点故障。
- **数据自动复制（Data Replication）**，确保多个数据节点存储相同数据。
- **自动故障恢复（Automatic Failover）**，数据节点崩溃时，其他节点继续提供服务。

### MySQL Cluster 如何处理数据分片？

- **自动分片（Auto-Sharding）**：数据根据 **主键哈希** 自动分布到不同数据节点。
- **用户可以手动控制分片规则**，提高查询效率。

### MySQL Cluster 和传统 MySQL 的区别是什么？

| 特性     | MySQL Cluster          | 传统 MySQL           |
| -------- | ---------------------- | -------------------- |
| 存储引擎 | NDB                    | InnoDB/MyISAM        |
| 高可用性 | 自动 Failover          | 依赖主从复制         |
| 扩展性   | 水平扩展（多数据节点） | 纵向扩展（升级硬件） |
| 事务支持 | 支持分布式事务         | 仅单机事务           |

### MySQL Cluster 的优点和缺点是什么？

**优点：**

- **高可用性**，自动 Failover。
- **支持分布式存储和计算**，可水平扩展。
- **实时数据同步**，低延迟。

**缺点：**

- **配置复杂**，管理成本高。
- **SQL 支持有限**，如不支持 `JOIN` 复杂查询。
- **占用内存较大**，所有数据需存储在内存或磁盘。

### 什么是 MySQL 异地多活？

MySQL **异地多活** 指的是 **多个数据中心同时提供服务**，避免单点故障，提高可用性。

### MySQL 异地多活的基本原理是什么？

- **双主模式（Active-Active）**：两个数据中心同时可写，使用 **冲突检测**。
- **主从模式（Active-Passive）**：一个数据中心主写，另一个数据中心备份。
- **基于中间件**（如 **MySQL MGR、TiDB**）处理跨地域数据同步。

### 如何保证 MySQL 异地多活的数据一致性？

- **基于 GTID 复制**，确保数据一致。
- **使用分布式事务（如 XA、TCC）**。
- **数据双写校验**，检测冲突并修正。

### 如何解决 MySQL 异地多活中的数据冲突？

- **基于时间戳** 确定最新数据。
- **业务层唯一性约束**（如订单号唯一）。
- **冲突检测+人工介入**，手动修正冲突数据。

### MySQL 异地多活可能面临的挑战有哪些？

- **数据同步延迟**，可能导致数据不一致。
- **网络抖动**，影响数据复制。
- **事务冲突**，需要冲突解决机制。

### 为什么需要进行数据备份与恢复？

- **防止数据丢失**（人为误删、硬件故障）。
- **支持历史数据回溯**。
- **快速恢复系统**，降低业务影响。

### 常见的 MySQL 数据备份方式有哪些？

- **物理备份**（`mysqldump`、`xtrabackup`）
- **逻辑备份**（`SELECT INTO OUTFILE`）
- **增量备份**（基于 binlog）

### 物理备份和逻辑备份的区别是什么？

| 备份方式 | 适用场景       | 速度 | 还原方式     |
| -------- | -------------- | ---- | ------------ |
| 物理备份 | 大规模数据     | 快   | 拷贝数据文件 |
| 逻辑备份 | 结构化数据迁移 | 慢   | SQL 语句导入 |

### 如何进行灾难恢复？

1. **确定灾难类型**（数据丢失、数据库损坏）。
2. **选择合适的备份**（全量 or 增量）。
3. **恢复数据库**（`mysqlbinlog` 回放 binlog）。
4. **验证数据一致性**，确保业务恢复正常。
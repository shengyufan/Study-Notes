[toc]
<div STYLE="page-break-after:always;"></div>

# C

## 变量

基本原则：标识符只能有字母、数字和下划线组成，数字不可以出现在第一个位置上，关键字不能作为标识符

`scanf` 函数：读入用户输入

`printf` 函数：输出程序结果

## 常量

`const` 关键字表示修饰的变量的值一旦初始化，就不能再修改，即声明了一个常量

## 数学运算

整数运算结果一定为整数

表达式：一系列运算符和蒜子的组合，用来计算一个值

运算符：进行运算的动作

算子：参与运算的值，可以是常数，变量或者一个方法的返回值

### 运算优先级

| 优先级 | 运算符 | 运算     | 结合关系 | 举例 |
| ------ | ------ | -------- | -------- | ---- |
| 1      | +      | 单目不变 | 自右向左 | a*+b |
| 1      | -      | 单目取负 | 自右向左 | a*-b |
| 2      | *      | 乘       | 自左向右 | a*b  |
| 2      | /      | 除       | 自左向右 | a/b  |
| 2      | %      | 取余     | 自左向右 | a%b  |
| 3      | +      | 加       | 自左向右 | a+b  |
| 3      | -      | 减       | 自左向右 | a-b  |
| 4      | =      | 赋值     | 自右向左 | a=b  |

关系运算符的优先级比算术运算低，但比赋值运算高

关系运算符中判断是否相等（`==` 和 `!=`）的优先级比其他低

连续的关系运算是从左到右进行的

## `sizeof`

该函数返回变量所对应的字节数，注意 sizeof 为静态函数，其中的参数不会进行

```c
int a = 6;
sizeof(a++); // 4
printf(a); // 6
```

常见的类型与字节数对应关系

| 类型             | 32 位系统（字节） | 64 位系统（字节） | 备注                                    |
| ---------------- | ----------------- | ----------------- | --------------------------------------- |
| `char`           | 1                 | 1                 | 通常是 8 位                             |
| `short`          | 2                 | 2                 | 通常是 16 位                            |
| `int`            | 4                 | 4                 | 通常是 32 位                            |
| `long`           | 4                 | 8                 | LP64 模型下，long 在 64 位是 8 字节     |
| `long long`      | 8                 | 8                 | 至少 64 位                              |
| `float`          | 4                 | 4                 | IEEE 754 单精度                         |
| `double`         | 8                 | 8                 | IEEE 754 双精度                         |
| `long double`    | 12/16             | 16                | 依平台而定，常为 80 位或 128 位扩展精度 |
| 指针类型 `T *`   | 4                 | 8                 | 与平台地址总线宽度相关                  |
| `_Bool` / `bool` | 1                 | 1                 | C99 引入的布尔类型                      |

## 不同的进制

程序中除十进制以外，还可以使用 8 进制或 16 进制

以 0 开始表示为 8 进制，以 0x 开始表示为 16 进制

```c
char c = 012;
int i = 0x12;
printf("%d", c); // 10
printf("%d", i); // 18
```

## 浮点数

浮点数无法进行精确计算，并且两个浮点数的比较通常采用差值比较法

```c
float a, b, c;

// 使用 f 标识为 float 而非 double
a = 1.345f;
b = 1.123f;
c = a + b;

// 错误的比较方法
if (c == 2.468) {
    printf("相等\n");
} else {
    printf("不相等\n");
}

// 正确的比较方法
if (fabs(c - 2.468) < 1e-8) {
    printf("相等\n");
} else {
    printf("不相等\n");
}
```

### 内部结构

一个 **64 位 double** 类型浮点数在内存中的二进制布局如下：

- **Sign（符号位）**：1 位  
  - 位于最高位（bit 63）  
  - 0 表示正数，1 表示负数
- **Exponent（指数位）**：11 位  
  - 位于 bit 62 ~ bit 52  
  - 存储的是偏移指数（偏移量 bias = 1023）
- **Fraction（尾数/小数部分）**：52 位  
  - 位于 bit 51 ~ bit 0  
  - 存储有效数字的小数部分（不含隐藏的整数位 1）

 浮点数的实际值计算公式：

$$  (-1)^{sign} \times 1.fraction \times 2^{exponent - bias} $$

其中：
- **sign**：符号位  
- **fraction**：尾数部分  
- **exponent**：指数部分（已加上偏移量 bias）

### 硬件实现
- 浮点数在计算时是由专用的 **浮点运算单元（FPU）** 实现的
- 计算 `double` 和 `float` 所用的硬件部件是相同的，只是精度和位数不同：
  - `float`：1 位符号 + 8 位指数 + 23 位尾数
  - `double`：1 位符号 + 11 位指数 + 52 位尾数

## 函数

### 原型

函数头，以分号 `;` 结尾，就构成了函数的原型

函数原型是为了声明函数，从而让编译器知道函数长什么样，其信息包括

-   名称
-   参数（数量及类型）
-   返回类型

```c
#include <stdio.h>

void sum(int a, int b);	// 声明

int main()
{
    sum(1,10);
    sum(20,30); 
    sum(35,45);
    return 0;
}

void sum(int begin, int end)	// 定义
{
    int i; 
    int sum = 0;
    for (i = begin; i <= end; i++ ) {
	    sum += 1;
    }
    printf("the sum from %d to %d is %d\n", begin, end, sum);
}
```

### 本地变量规则

-   本地变量是定义在块内的
    -   ﻿﻿可以是定义在函数的块内
    -   ﻿﻿也可以定义在语句的块内
    -   ﻿甚至可以随便拉一对大括号来定义变量
-   ﻿程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了
-   ﻿﻿块外面定义的变量在里面仍然有效
-   ﻿﻿块里面定义了和外面同名的变量则掩盖了外面
-   不能在同一块中定义同名变量
-   本地变量不会被默认初始化
-   参数在进入函数时会进行初始化

## 取址运算符 `&`

获取变量的地址，操作数必须是变量

地址的大小是否与 int 类型相同取决于编译器

使用 `%p` 输出地址

## 指针 `*`

保存地址的变量，用来访问指针的值所表示的地址上的变量

### 应用场景

1.   交换两个变量的值
2.   函数返回多个值，某些值只能通过指针返回，其传入参数实际上是保存需要带回的结果变量
3.   函数返回运算状态，结果通过指针返回

### 数组变量是特殊的指针

函数参数表中的数组实际是指针

数组变量本身表达地址，所以

-   ﻿int a[10]; int*p=a; //无需用&取地址
-   ﻿但是数组的单元表达的是变量，需要用&取地址
-   ﻿﻿a == &a[0]

`[]` 运算符可以对数组做，也可以对指针做：

-   p[0] <==> a[0]

\* 运算符可以对指针做，也可以对数组做：

-   *a= 25；

数组变量是 const 的指针，所以不能被赋值，也不能将一个数组赋值给另一个

-   int a[] <==> int * const a

### 指针与 const

`int * const p = &i;`：不能对 p 进行修改或运算

`const int* p = &i;`：不能通过 p 对 i 进行修改

### 指针运算

给一个指针加 1 表示要让指针指向下一个变量，但如果指针不是指向一块连续分配的空间（如数组），则这种运算没有意义

`*p++`：取出 p 所指的数据，进行加 1 操作后，将指针 p 移到下一个位置。该操作常用于数组类的连续空间操作

指针还可以使用 `<, <=, ==, >, >=` 等操作符，比较两个指针在内存中的地址

### 0 地址

内存中有 0 地址，但是 0 地址通常是个不能随便碰的地址，﻿﻿所以你的指针不应该具有0值

﻿﻿可以用 0 地址来表示特殊的事情：

-   ﻿﻿返回的指针是无效的
-   指针没有被真正初始化（先初始化 0 ）

﻿﻿NULL 是一个预定定义的符号，表示 0 地址

-   ﻿﻿有些编译器不愿意你用 0 来表示 0 地址

### 类型转换

指向不同类型的指针不能直接赋值

`void*` 表示不知道指向什么类型的指针，可以用于指针的类型转换，常用于底层实现

```c
int *p = &i;
void* q = (void*)p;
int* t = (int*)q;
```

### 动态内存分配

```c
#include <stdlib.h>

// 申请内存空间（字节数）
int* a = (int*)malloc(n * sizeof(int));

// 释放空间
free(a);
```

在 C99 之前实现连续内存空间的分配

如果申请失败，则返回 NULL 或 0

## 字符串

以 `\0` 结尾的一串字符，该位标志字符串的结束，但并不包含在字符串中

字符串以数组的形式存在，以数组或**指针**的访问，可通过数组的方式遍历字符串

不能用运算符对字符串做运算

如果使用指针定义字符串，则不能在原地址上进行修改，即只读。但可以通过数组定义进行修改

```c
char *s = "Hello!";
s[0] = 'h'; // 操作报错
char t[] = "Hello!";
t[0] = 'h'; // 操作成功
```

如果多个字符串相同，则会指向同一个地址

```c
// a 和 b 指向同一地址
char *a = "hello";
char *b = "hello";
```

### 空字符串

```c
// 空字符串
char buff[100] = "";

//数组长度只有 1
char buff[] = "";
```

### 相关函数

`putchar` 与 `getchar`：单字符输出和输入

```c
#include <stdio.h>

int main() {
    char c;

    printf("请输入一个字符: ");
    c = getchar();    // 从键盘读取一个字符

    printf("你输入的是: ");
    putchar(c);       // 输出这个字符
    printf("\n");

    return 0;
}
```

`strlen`：返回字符串的长度

`strcmp`：比较两个字符串，返回值为两个字符串的差值，即返回 0，两者相同；返回正值，前者大；返回负值，后者大

`strcpy`：将一个字符串拷贝到另一个字符串中，注意参数表中目的字符串在前，源字符串在后

`strchr/strstr/strcasestr`：在字符串中寻找单个字符/字符串/忽略大小写的字符串

## 枚举

用户定义的数据类型，使用关键字 `enum` 声明枚举

```c
enum colors {red, yellow, green};
```

枚举只是 int，如果未声明，则从 0 开始依次递增。枚举也可以自定义赋值

## 结构

结构声明了一种新的数据类型

声明结构的形式

```c
// 1
struct point {
    int x;
    int y;
};
struct point p1, p2;

// 2
struct {
    int x;
    int y;
} p1, p2;

// 3
struct point {
    int x;
    int y;
} p1, p2;
```

第一和第三种形式都声明了结构 point，但第二种形式没有声明 point，只是定义了两个变量

对于整个结构，可以做赋值、取址，也可以传递给函数参数

和数组不同，结构变量的名字并不是结构变量的地址，必须使用 `&` 运算符

```c
struct date today;
struct date *pDate = &today;
```



# C++

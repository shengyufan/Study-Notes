[toc]



<div STYLE="page-break-after:always;"></div>

### 什么是关系模式？

关系模式是数据库以表（关系）的形式组织数据，规定了数据如何在表中存储和组织，主要包括关系名，属性集和约束条件

### 表的抽象，表由哪些元素构成？

表中描述了一批相互有关联关系的数据，其主要由3部分组成

- 关系名：用于标识和引用该表
- 属性集：表中列的集合，每个属性都有一个名称和一个域（所有可能取值的集合）
- 元组集：表中行的集合，每个元组（记录）是一组按照属性顺序排列的值，代表一条完整的数据记录

### 区分DDL，DML，DCL

DDL：数据定义语言，用于数据库和数据表的创建，修改和删除

DML：数据操纵语言，用于添加，删除，修改和查询数据库记录

DCL：数据控制语言，用于定义用户的访问权限和安全级别

### 描述MySQL基本架构

MySQL采用标准的分层结构

**客户端层**

- 客户端程序（如 MySQL 客户端、应用程序）通过网络与服务器进行通信，发送 SQL 请求并接收查询结果。

**连接管理与安全验证**

- **连接管理器**：负责接受客户端连接、创建连接线程，并为每个连接分配资源。
- **安全验证**：在建立连接时对用户进行身份验证和权限检查。

**SQL 层**

- **解析器（Parser）**：将客户端提交的 SQL 语句进行词法和语法分析，生成内部表示（解析树）。
- **预处理器**：检查 SQL 语句的合法性，并进行变量替换、权限检查等操作。
- **查询优化器**：对解析后的 SQL 语句进行重写和优化，生成最优的执行计划，包括选择合适的索引、查询重排序等。
- **查询执行器**：按照执行计划调用相应的存储引擎接口执行具体的数据操作。

**缓存与内存管理**

- **查询缓存**：在某些版本中，MySQL 会缓存查询结果，减少重复查询的开销。
- **各种内存缓冲区**：如排序缓冲区、连接缓冲区、临时表等，用于加速数据处理和查询执行。

**存储引擎层**

- **存储引擎接口**：为 SQL 层提供统一的数据存储接口，使得不同的存储引擎可以独立实现数据存储、索引、事务处理等功能。
- **存储引擎**：如 InnoDB（支持事务、行级锁）、MyISAM（适用于只读或读多写少场景）、Memory（基于内存的高速存储）、CSV 等。不同的存储引擎具有各自的优缺点，用户可以根据具体需求进行选择。

### 关系模式、层次模式、网状模式的区别

**关系模式（关系模型）**

- **数据结构**：以二维表（关系）的形式组织数据，每个表由行（记录）和列（属性）构成。
- **数据独立性**：数据和操作（查询、更新等）之间的逻辑分离，用户可以通过关系代数或 SQL 来操作数据，而不必关心数据的物理存储。
- **灵活性**：支持复杂查询、联接和数据操作，适用于多种复杂数据关系。

**层次模式（层次数据库模型）**

- **数据结构**：以树状结构组织数据，每个节点（记录）只有一个父节点，可以有多个子节点。
- **访问方式**：数据存取主要依赖从根节点向下的路径导航，查询时通常需要按照预定义的层次结构逐层查找。
- **适用场景**：适合具有明显层次关系的一对多场景，如组织结构、文件系统等。

**网状模式（网络数据库模型）**

- **数据结构**：采用图的结构组织数据，允许记录之间存在多对多的关系，即一个节点可以有多个父节点和多个子节点。
- **访问方式**：依赖指针（或链接）进行数据导航，查询时需要沿着预定义的连接关系查找数据。
- **灵活性**：比层次模型更加灵活，适合复杂的多对多关系数据结构，如供应链管理、复杂业务流程等。

### 什么是笛卡尔积？

广义笛卡尔积是两个关系的元组所有可能的拼接元组的集合，即将来自第一个表的记录与第二个表中的每一条记录组合在一起

### 区分候选码和主键

候选键是关系中一个属性或属性组，其值可以唯一标识一个元组

当有多个候选键时，可以选定一个候选键作为主键

### 区分主键和外键

主键是可唯一标识关系中一个元组的属性或属性组

外键是关系中一个非候选键的属性组，但与另一个关系的候选键对应，两个关系通常由外键所连接

### 关系模式有哪些基本操作，有哪些拓展操作？

基本操作包含并，差，广义笛卡尔积，选择和投影

拓展操作包含交，$\theta$-连接，等值连接，自然连接，除和外连接

### 什么是子查询？举例说明

出现在Where子句中的Select语句被称为子查询，子查询返回了一个集合，可通过与这个集合的比较确定另一个集合

子查询主要可分为3类

- (NOT) IN 子查询

  ```sql
  # 返回选修了001号课程的所有学生的学号和姓名
  SELECT sid, sname
  FROM student 
  WHERE sid in
  	(SELECT sid FROM sc WHERE cid = '001');
  ```

- $\theta$-some/$\theta$-all 子查询

  ```sql
  # 返回工资最低的教师姓名
  SELECT tname
  FROM teacher
  WHERE salary <= ALL(SELECT salary FROM teacher);
  ```

- (NOT) EXISTS 子查询

  ```sql
  # 返回没上过李四老师课的所有学生姓名
  SELECT sname 
  FROM student 
  WHERE NOT EXISTS 
  	(SELECT * 
     FROM course, sc, teacher 
     WHERE tname = '李四' AND course.tid = teacher.tid
     AND course.cid = sc.cid AND sid = student.sid);

### 如何创建视图？视图有什么优点？

视图是一种虚拟表，它不存储数据，而是基于SQL查询语句的结果集动态生成，使用`CREATE VIEW`语句创建视图

优点

**数据抽象与封装**

- **简化复杂查询**：将复杂的多表连接或计算逻辑封装在视图中，使用视图查询时只需调用视图名称，而不必重复编写复杂 SQL 语句。
- **隐藏数据细节**：通过视图，可以隐藏底层数据的结构和敏感信息，只暴露必要的数据给用户。

**安全性**

- **权限控制**：通过给用户授权访问视图而不是底层表，可以限制用户对数据的访问范围，从而提高数据安全性。
- **数据保护**：可以在视图中只展示部分列或经过处理的数据，避免直接暴露原始数据。

**维护和管理**

- **集中业务逻辑**：当业务逻辑发生变化时，只需修改视图定义，而不必逐个修改所有使用该逻辑的 SQL 语句。
- **简化应用程序代码**：通过使用视图，应用程序可以直接查询视图，减少了对底层表结构的依赖，使系统更易于维护和升级。

**重用性**

- **一致的数据接口**：视图提供了一种统一的查询接口，多个应用程序可以复用同一个视图，从而保持数据的一致性和完整性。

### 数据库游标的作用是什么？

当嵌入式SQL语句返回多行结果时，需要使用游标逐行读取结果

### 静态SQL和动态SQL的区别是什么？

静态SQL：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量传递给嵌入式SQL语句即可

动态SQL：SQL语句可以在程序中动态构造，形成一个字符串，然后交给DBMS执行，仍然可以传递变量

### 描述磁盘的原理

磁盘由盘面，磁道和扇区构成。当需要读取或写入数据时，硬盘控制器通过计算出数据所在的磁道和扇区，然后通过磁臂将读写磁头精确移动到目标位置。

### 什么是RAID技术？

RAID技术是一种通过将多个物理硬盘组合成一个逻辑存储单元的方法，以实现数据冗余，性能提升和容量扩展的技术。这项技术实现了并行处理，通过提供奇偶校验与纠错保证了数据的可靠性

RAID常分为6个级别：1）块级拆分但无冗余；2）镜像处理；3）位交叉纠错处理；4）位交叉校验；5）块交叉校验；6）块交叉分布式校验

### 为什么需要索引？

索引是定义在存储表基础之上的一种辅助存储结构，实现了无需检查所有记录从而可快速定位所需记录，同时索引文件相比于主文件小很多，更容易全部加在进内存之中

### 如何衡量索引的好坏？

衡量标准主要包括

- 访问时间
- 插入时间
- 删除时间
- 空间负载
- 支持存取的有效性（支持单值查询或范围查询）

### 区分排序码、索引码、搜索码

排序码：对主文件进行排序存储的属性或属性组

索引码：索引字段，不一定具有唯一性

搜索码：在主文件中查找记录的属性或属性组

### 稀疏索引和稠密索引的区别

稠密索引：对于主文件中**所有**记录，都有一个索引项和指明所在位置的索引

稀疏索引：对于主文件中**部分**记录，有索引项和对应位置的索引

### 主索引和辅助索引的区别

主索引对每一存储块有一个索引项，索引项总数和存储表所占存储块数目相同。存储表的每一存储块的第一条记录（锚记录）

辅助索引定义在主文件的任一或多个非排序字段的辅助存储结构

### 倒排索引是什么？

倒排索引是一种常用于全文检索和搜索引擎的数据结构，其主要作用是建立从词项（关键词）到文档集合（包含这些关键词的文档）的映射关系

### B+ Tree和二叉树的区别

在**结构**上，二叉树每个节点最多只能有两个子节点，但B+树是一种多路平衡查找树，每个节点可以有多个子节点

在**数据存储**方面，二叉树中的数据分布在每个节点中，而B+树非叶结点只存储索引，所有数据都集中存储在叶子结点中

在**平衡性**上，二叉树不一定保持平衡，且普通的二叉搜索树可能退化为链表，降低查找效率，但B+树通过算法保证了严格的平衡性，即所有叶子结点都处于同一层次

在**更新与维护**方面，二叉自平衡树插入、删除可能需要旋转操作来重新平衡，而B+树插入操作可能涉及节点分裂，删除操作可能涉及节点合并

### 描述B+ Tree读写流程

当查询一个键或范围时，B+ 树的**读**取流程大致如下：

1. **从根节点开始**
   - 读取根节点（通常已缓存在内存中），从根节点中找到合适的指针，确定目标键所在的子树。
2. **沿着内部节点向下遍历**
   - 根据目标键与内部节点中分隔键（separator keys）的比较结果，选择合适的子指针。
   - 依次加载相应的内部节点，直到到达叶子层。
   - 每一步都利用内部节点存储的分界信息快速定位下一层的节点，减少磁盘读取次数。
3. **在叶子节点中查找**
   - 到达叶子节点后，在该节点的键列表中查找目标键（或符合范围条件的键）。
   - 如果查找的是单个键，则直接返回对应的数据指针；如果是范围查询，利用叶子节点之间的链表顺序访问连续的叶子节点，逐步返回满足条件的所有记录。

**写**操作（如插入和删除）需要保持树的平衡和节点的有序性，流程大致如下：

**插入操作**

1. **定位目标叶子节点**
   - 类似读取流程，首先从根节点开始，按照分界键逐层定位到应插入目标键的叶子节点。
2. **在叶子节点中插入键**
   - 将目标键插入到叶子节点中，并保持节点内的键按升序排列。
3. **处理节点溢出**
   - 如果叶子节点插入后超出了预设的最大键数（即节点溢出），则需要进行节点分裂
     - 将叶子节点分裂成两个节点，一般取中间位置作为分界点。
     - 将分裂产生的新节点的最小键提升到父节点，作为新的分界键。
   - 如果父节点因此也溢出，则同样递归地进行分裂，直到达到根节点。
   - 如果根节点分裂，则树的高度会增加一层。
4. **更新父节点指针**
   - 分裂操作后，需要更新父节点的指针和分界键，以确保整个树结构保持有序和平衡。

**删除操作**

1. **定位目标叶子节点**
   - 从根节点开始，逐层定位到包含目标键的叶子节点。
2. **在叶子节点中删除键**
   - 从叶子节点中删除目标键，并保持节点内其他键的有序性。
3. **处理节点下溢**
   - 如果删除操作导致叶子节点中的键数低于预设的下限（即节点下溢），需要通过合并或借用操作恢复平衡：
     - **借用**：若相邻兄弟节点有多余的键，可以从兄弟节点借一个键，并更新父节点的分界键。
     - **合并**：如果兄弟节点也无法借用，则将下溢节点与相邻兄弟节点合并，并删除父节点中对应的分界键。
   - 同样，父节点的调整可能会递归传播，直到树重新达到平衡。

### B+ Tree各项操作的时间复杂度

| 操作                   | 时间复杂度      |
| ---------------------- | --------------- |
| 查找 (Search)          | $O(\log n)$     |
| 插入 (Insert)          | $O(\log n)$     |
| 删除 (Delete)          | $O(\log n)$     |
| 范围查询 (Range Query) | $O(\log n + k)$ |

### B+ Tree和哈希表的区别

**数据结构与存储方式**

- B+ Tree
  - 是一种多路平衡查找树，所有数据记录都存储在叶子节点中，内部节点仅存储索引信息。
  - 数据按键值有序排列，叶子节点之间通常通过链表相连，便于顺序遍历和范围查询。
- 哈希表
  - 采用哈希函数将键映射到桶中，数据存储无序。
  - 依赖键的哈希值进行快速定位，不维护数据的顺序。

**查询和操作能力**

- B+ Tree
  - 查找、插入、删除操作的时间复杂度均为 $O(\log n)$。
  - 由于数据有序，非常适合范围查询、排序和顺序扫描。
- 哈希表
  - 平均情况下查找、插入、删除操作时间复杂度为 $O(1)$，但最坏情况下可能退化到 $O(n)$（取决于哈希函数和冲突处理策略）。
  - 主要用于精确查找，不支持高效的范围查询和顺序遍历。

**适用场景**

- B+ Tree
  - 常用于数据库和文件系统的索引结构，尤其适合大规模数据的磁盘存储。
  - 能有效减少磁盘I/O次数，支持范围查询和有序数据处理。
- 哈希表
  - 主要用于内存中的数据存储和快速查找，如缓存系统和散列集合。
  - 不适合需要排序或范围查询的场景。

**扩展性与维护**

- B+ Tree
  - 通过节点分裂和合并等操作，能在数据频繁变动时保持树的平衡，确保查询效率稳定。
  - 数据存储与磁盘块对齐，便于扩展大容量存储。
- 哈希表
  - 随着数据量增大可能需要重新哈希（rehash）以扩展容量，可能引入额外的开销。
  - 数据在内存中存储，受内存大小限制。

### B+ Tree和B Tree的区别

**数据存储位置**

- B Tree
  - 数据既可以存储在内部节点，也可以存储在叶子节点。
  - 内部节点既作为索引，也直接保存部分数据。
- B+ Tree
  - 所有实际数据都存储在叶子节点中，内部节点只存储用于索引的关键字。
  - 这种设计使得 B+ Tree 的内部节点容量更大，从而降低树的高度。

**顺序访问和范围查询**

- B Tree
  - 内部节点和叶子节点都存储数据，顺序遍历不如 B+ Tree 那样高效。
- B+ Tree
  - 叶子节点通常通过指针（链表）相互连接，便于进行顺序扫描和范围查询。
  - 因此，在需要按顺序访问数据（如数据库中的范围查询）时，B+ Tree 更具优势。

**树的高度与磁盘 I/O**

- B Tree
  - 由于数据分布在所有节点，树的高度可能略高，查找过程中需要读取更多的节点。
- B+ Tree
  - 内部节点仅存储索引，能容纳更多的关键字，从而降低树的高度。
  - 较低的高度意味着在磁盘环境下可以减少磁盘 I/O 次数，提高性能。

**更新操作**

- B Tree
  - B 树没有冗余节点，插入或删除数据时，可能直接在内部节点修改数据，这可能引起更多的节点调整。
- B+ Tree
  - B+ 树有大量的冗余节点，更新操作主要集中在叶子节点，内部节点只负责维护索引，更新过程相对简单且更有利于批量数据的处理。

### 描述散列索引的基本原理

散列的目的是选择一个合适的散列函数，将一个集合均匀映射到每个桶中，即对于集合任一关键字，散列函数映射到地址集合中任何一个地址的概率是近乎相等的

散列索引一种利用哈希函数将关键字映射到存储桶中的索引结构。内存数据可采用散列确定存储页，主文件可使用散列确定存储块，索引可利用散列确定索引项的存储块

### 区分静态散列索引、动态散列索引

静态散列索引和动态散列索引的主要区别在于存储桶的数目是否固定。静态散列索引中桶的数目为固定值，而动态散列索引中存储桶的数目会随键值增多从而动态增加

### 描述查询优化的基本思路

查询优化的基本思路主要是将用户提交的SQL查询转换为一个高效的执行计划，从而最小化资源消耗和响应时间。其核心步骤和思路包括：

1. **语法和语义解析**
   - 将SQL查询解析成内部的表示（如解析树或查询图），并进行语义检查，确保查询合法。
2. **查询重写**
   - 对查询进行逻辑重写，应用等价转换规则（如谓词下推、消除冗余、合并查询等），将查询表达式转化为更便于优化和执行的形式。
3. **逻辑优化**
   - 利用关系代数的转换规则对查询计划进行重构，调整操作顺序、合并操作等，从逻辑上降低查询代价。例如：
     - **谓词下推**：将选择和投影尽可能早执行，减少后续操作处理的数据量。
     - **子查询优化**：将子查询转化为连接或其他更高效的操作。
4. **物理优化与执行计划生成**
   - 根据数据库中表的统计信息和数据分布情况，为逻辑操作选择合适的物理实现方式（如全表扫描、索引扫描、不同的连接算法等）。
   - 优化器会评估多个备选方案，计算每个方案的预估成本（CPU、I/O、内存等），选择成本最低的执行计划。
5. **索引与连接顺序的选择**
   - 在多表连接的查询中，优化器会根据表的数据量、索引情况以及连接条件来确定最佳的连接顺序和连接算法（例如嵌套循环、哈希连接、归并连接等）。
   - 合理利用索引可以大幅降低数据访问量，提高查询性能。
6. **成本模型与统计信息**
   - 查询优化依赖于数据库统计信息（如表的行数、数据分布、索引基数等）以及成本模型来预测执行计划的代价。
   - 通过不断更新统计信息，优化器可以更准确地选择最优计划。

### 什么是语法优化？举例说明

在SQL语句经过语法解析后，利用一系列预定义的重写规则，将原始查询重写为一个逻辑上等价但更易于高效执行的查询。其目标在于降低数据扫描量、减少中间结果并充分利用索引，从而提高查询性能

例如通过等价交换，改变关系代数的操作顺序，尽可能早做**选择**和**投影**运算，避免大表之间的连接操作

### 什么是执行优化？举例说明

存取路径和执行算法的选择与执行顺序的优化，主要关注如何将经过语法和逻辑优化后的查询转换为具体的物理执行计划。这个过程涉及选择合适的算法、数据访问方式和操作顺序，以最小化查询的资源消耗和响应时间

例如对于一条SQL查询，物理执行阶段可能通过对WHERE子句的查询属性建立索引结构从而避免全表扫描

### 如何衡量物理查询计划的优劣？

衡量指标包括1）I/O访问次数；2）CPU占用时间；3）内存使用代价；4）中间结果存储代价；5）计算量；6）网络通信量等

### 什么是事务的ACID？

**原子性**(Atomicity)：一个事务中的所有操作要么全部完成，要么全部不完成，不会结束在中间的某个环节。并且在执行过程中如果出现错误，会回滚到开始前的状态

**一致性**(Consistency)：一个事务操作前和操作后的数据要满足完整性约束，数据库保持一致性状态

**隔离性**(Isolation)：因为数据库允许多个并发事务同时对其数据进行读写和修改，所以需要将每个事务隔离开，保证一个事务的执行不会影响到其他事务

**持久性**(Durability)：一旦事务被提交，它对数据库的改变就是永久性的，即使在系统故障或崩溃后也能够保持，被撤销事务的影响是可恢复的

### MySQL的四种隔离级别是什么？

**读未提交**(read uncommitted)：允许一个事务读取另一个事务尚未提交的数据修改。这是最低的隔离级别，存在脏读，不可重复读和幻读的问题

**读提交**(read committed)：一个事务只能读取已经提交的数据。其他事务的修改在该事务提交之后才可见。解决了脏读的问题，但依然可能出现另外两种问题

**可重复读**(repeatable read)：事务执行期间，多次读取同一数据会得到相同的结果，即在事务开始和结束之间，其他事务对数据的修改不可见。进一步了不可重复读问题

**串行化**(serializable)：最高的隔离级别，确保事务之间的并发执行效果与串行执行的效果相同，即不会出现脏读、不可重复读和幻读

### 数据库有哪几种类型的故障？

**事务故障**：某个事务自身运行错误所引起的故障，影响事务本身

**系统故障**：由于掉电、非正常关机等所引起的故障，影响正在运行的事务及数据库缓冲区

**介质故障**：由于介质损坏所引起的故障，全面影响内存中的数据和介质中存储的数据

### 事务故障如何恢复？

重做事务（保证已提交事务的持久性）和撤销事务（消除未提交事务的影响）

### 系统故障如何恢复？

运行日志，恢复每个事务所完成的操作

### 介质故障如何恢复？

使用副本恢复后运行日志

### 什么是日志？

一个包含日志记录的**只能追加**的顺序文件，不同事务的日志记录交错存储，按发生时间存储

日志记录信息包括1）事务开始；2）事务完成；3）事务未成功，被中止；4）某个事务改变数据库元素

### 区分redo和undo日志

**redo日志**：在执行完更新SQL语句，数据已经完成修改之后，我们还需要将修改记录到重做日志中。重做日志是一个物理日志，记录某个数据页做了什么样的修改，并且在事务提交时，重做日志也会持久化到磁盘中，所以当数据库服务崩溃时，就可以利用重做日志将数据恢复到最新状态，因此重做日志保证了事务的持久性

**undo日志**：在事务的执行过程中发生了崩溃之后，我们需要将数据回滚到事务开始前的状态，而这就需要用到回滚日志。因此回滚日志保证了事务的原子性。其主要的工作原理就是在执行事务时，会同时将更新前的数据记录在回滚日志中，假如出现了崩溃，就可以从这个日志中恢复原数据了